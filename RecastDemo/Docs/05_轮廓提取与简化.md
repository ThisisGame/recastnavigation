# Step 5：轮廓提取与简化

## 1. 概述

Step 5 从区域划分完成的紧凑高度场中，沿每个区域的边界提取轮廓线，
然后使用 Douglas-Peucker 算法简化轮廓，并处理孔洞（hole）的合并。

**关键函数**：`rcBuildContours()`

**源文件**：`Recast/Source/RecastContour.cpp`

---

## 2. 轮廓提取流程

```mermaid
flowchart TD
    A[紧凑高度场<br/>每个 Span 有区域 ID] --> B["标记边界边<br/>flags[i] = 哪些方向是区域边界"]
    B --> C["遍历所有 Span"]
    C --> D{flags[i] != 0<br/>且 flags[i] != 0xf?}
    D -- 否 --> C
    D -- 是 --> E["walkContour:<br/>沿边界行走,记录顶点"]
    E --> F["simplifyContour:<br/>Douglas-Peucker 简化"]
    F --> G["存储为 rcContour"]
    G --> C
    C --> H["计算轮廓绕向 (winding)"]
    H --> I["合并孔洞到外轮廓"]
```

### 2.1 边界标记

对每个 Span 检查四个方向的邻居，标记哪些方向是区域边界：

```cpp
for (int dir = 0; dir < 4; ++dir) {
    unsigned short r = 0;  // 邻居的区域 ID
    if (rcGetCon(s, dir) != RC_NOT_CONNECTED) {
        // 获取邻居的区域 ID
        r = chf.spans[neighborIndex].reg;
    }
    if (r == chf.spans[i].reg)
        res |= (1 << dir);  // 同一区域，不是边界
}
flags[i] = res ^ 0xf;  // 取反，标记非连通边（= 边界边）
```

```
flags 位含义 (4 位):
  bit 0 = 方向 0 (-X) 是否为边界
  bit 1 = 方向 1 (+Z) 是否为边界
  bit 2 = 方向 2 (+X) 是否为边界
  bit 3 = 方向 3 (-Z) 是否为边界

flags = 0x0: 四个方向都连通 (内部 Span, 不在边界上)
flags = 0xf: 四个方向都不连通 (孤立 Span, 跳过)
其他值: 部分方向是边界
```

### 2.2 walkContour 边界行走

从一个边界 Span 开始，沿着区域边界顺时针行走，记录所有转角顶点：

```
区域 A 的边界追踪示意:

    ┌───┬───┬───┐
    │ B │ B │ B │
    ├───┼───┼───┤
    │ B │ A │ A │  ← 从这里开始，沿边界行走
    ├───┼───┼───┤  
    │ B │ A │ A │  箭头方向: → ↓ ← ↑ (顺时针)
    ├───┼───┼───┤
    │ B │ B │ B │
    └───┴───┴───┘

输出顶点: (1,1), (3,1), (3,3), (1,3) — 区域 A 的矩形轮廓
```

每个顶点存储 4 个值: `(x, y, z, regionConnection)`
- `regionConnection`: 该边连接到哪个相邻区域（用于后续邻接图构建）

---

## 3. 轮廓简化

### 3.1 Douglas-Peucker 算法

```
原始轮廓 (很多顶点):
  ·─·─·─·─·─·─·─·─·
  │                 │
  ·                 ·
  │                 │
  ·─·─·─·─·─·─·─·─·

简化后 (仅保留关键顶点):
  ·─────────────────·
  │                 │
  ·                 ·
  │                 │
  ·─────────────────·
```

简化规则：
1. **必须保留的顶点**：区域连接发生变化的位置（portal 顶点）
2. **可选保留的顶点**：偏离直线距离 > `maxSimplificationError` 的顶点
3. **边长限制**：简化后的边长超过 `maxEdgeLen` 时，在该边中间插入额外顶点

### 3.2 maxSimplificationError 的影响

```
maxSimplificationError = 1.0:        maxSimplificationError = 3.0:
  ·───·───·                            ·───────·
  │       │                            │       │
  ·       · ← 保留（偏离 > 1）         │       │ ← 被移除（偏离 < 3）
  │       │                            │       │
  ·───·───·                            ·───────·
  
更精确，更多顶点                       更粗糙，更少顶点
```

---

## 4. 孔洞处理

### 4.1 绕向判断

轮廓提取完成后，计算每个轮廓的绕向（winding）：

```
正绕向 (逆时针, 面积 > 0): 外轮廓 (outline)
负绕向 (顺时针, 面积 < 0): 孔洞 (hole)
```

### 4.2 孔洞合并

每个区域应该有**一个外轮廓**和**零到多个孔洞**：

```
区域 A 的轮廓:
┌─────────────────┐  ← 外轮廓 (正绕向)
│                 │
│   ┌─────┐       │
│   │hole │       │  ← 孔洞 (负绕向，内部有障碍物)
│   └─────┘       │
│                 │
└─────────────────┘

合并后: 外轮廓被修改，将孔洞的顶点融入其中
```

`mergeRegionHoles()` 函数将孔洞合并到外轮廓中，通过找到最佳的"桥"连接外轮廓和孔洞。

---

## 5. rcContourSet 输出结构

```cpp
struct rcContour {
    int* verts;            // 简化后的顶点 [x, y, z, reg] * nverts
    int nverts;            // 简化后的顶点数
    int* rverts;           // 原始顶点 (未简化) [x, y, z, reg] * nrverts
    int nrverts;           // 原始顶点数
    unsigned short reg;    // 所属区域 ID
    unsigned char area;    // 区域类型
};

struct rcContourSet {
    rcContour* conts;      // 轮廓数组
    int nconts;            // 轮廓数量
    float bmin[3], bmax[3]; // 包围盒
    float cs, ch;          // 体素尺寸
    int width, height;     // 网格尺寸
    int borderSize;        // 边界大小
};
```

注意：
- 每个**区域**产生一个轮廓（孔洞已合并）
- `verts` 中的坐标是**体素坐标**（整数），不是世界坐标
- `rverts` 保留了未简化的原始轮廓，供 Debug 绘制使用
- 顶点的第 4 个分量 `reg` 记录了该边连接到的邻居区域
